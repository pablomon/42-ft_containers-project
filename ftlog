Using FT containers
[0;33m
T E S T I N G   M A P[0m
[0;33m
CONSTRUCTORS[0m
[0;36m
Empty constructor[0m
printing map
  size = 2
  k1 => v1
  k2 => v2
end of print

[0;36m
Range constructor[0m
printing source map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

printing destination map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

[0;36m
Copy constructor[0m
printing source map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

printing destination map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

[0;32mCONSTRUCTORS OK[0m
[0;33m
OPERATORS[0m
[0;36m
Assignment operator[0m
printing source map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

printing destination map
  size = 1
  k5 => v5
end of print

printing destination map after assignment
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

[0;33m
ITERATORS[0m
[0;36m
Iterators[0m
printing map
  size = 4
  k1 => v1
  k2 => v2
  k6 => v6
  k7 => v7
end of print

k7
k6
k2
k1
-------
k1
k1
k2
k2
-------
[0;36m
Constant iterators[0m
printing map
  size = 4
  k1 => v1
  k2 => v2
  k6 => v6
  k7 => v7
end of print

k7
k6
k2
k1
[0;36m
Reverse iterators[0m
printing map
  size = 4
  k1 => v1
  k2 => v2
  k6 => v6
  k7 => v7
end of print

k7
k6
k2
k1
[0;36m
Reverse constant iterators[0m
printing map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

k3
k2
k1
[0;33m
CAPACITY[0m
[0;36m
Empty & Size[0m
printing size map
  size = 0
end of print

Is empty = 1
printing size map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

Is empty = 0
printing size map
  size = 2
  k2 => v2
  k3 => v3
end of print

printing size map
  size = 0
end of print

[0;36m
Max size[0m
Max size = 144115188075855871
[0;32mCAPACITY OK[0m
[0;33m
ELEMENT ACCESS: Operator[][0m
printing map
  size = 1
  k1 => v1
end of print

printing map
  size = 2
  k1 => v1
  k2 => 
end of print

v1

[0;32mELEMENT ACCESS OK[0m
[0;33m
MODIFIERS[0m
[0;36m
Insert[0m
Single element
Single element with hint
printing map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

Range insert
printing Source map
  size = 3
  k4 => v4
  k5 => v5
  k6 => v6
end of print

printing Destination map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

Insert source map begin to end in destination map
printing Destination map after copy
  size = 6
  k1 => v1
  k2 => v2
  k3 => v3
  k4 => v4
  k5 => v5
  k6 => v6
end of print

[0;36m
Erase[0m
printing map
  size = 5
  k1 => v1
  k2 => v2
  k3 => v3
  k4 => v4
  k5 => v5
end of print

Erase single (iterator)
printing map
  size = 4
  k2 => v2
  k3 => v3
  k4 => v4
  k5 => v5
end of print

Erase single (key)
printing map
  size = 3
  k2 => v2
  k3 => v3
  k5 => v5
end of print

Erase range
printing map
  size = 1
  k2 => v2
end of print

[0;36m
Swap[0m
printing swapmapa
  size = 2
  k1 => v1
  k2 => v2
end of print

printing swapmapb
  size = 1
  k3 => v3
end of print

Swap maps..
printing swapmapa
  size = 1
  k3 => v3
end of print

printing swapmapb
  size = 2
  k1 => v1
  k2 => v2
end of print

[0;36m
Clear[0m
printing map
  size = 3
  k1 => v1
  k2 => v2
  k3 => v3
end of print

Clearing map...
printing map
  size = 0
end of print

[0;32mMODIFIERS OK[0m
[0;33m
OBSERVERS[0m
[0;36m
Key compare[0m
mymap contains:
a => 100
b => 200
c => 300

[0;36m
Value compare[0m
mymap contains:
x => 1001
y => 2002
[0;32mOBSERVERS OK[0m
[0;33m
OPERATORS[0m
[0;36m
Find[0m
printing map
  size = 4
  k1 => v1
  k2 => v2
  k3 => v3
  k4 => v4
end of print

k3 => v3
not found, iterator = end()
[0;36m
Count[0m
printing map
  size = 2
  k1 => v1
  k2 => v2
end of print

count k1 = 1
count k8 = 0
[0;36m
Lower Bound[0m
printing map
  size = 4
  k1 => v1
  k2 => v2
  k6 => v6
  k7 => v7
end of print

Lower bounds:
lowerbound(k2) = k2
lowerbound(k1) = k1
lowerbound(k4) = k6
lowerbound(k7) = k7

Const lower bounds:
lowerbound(k2) = k2
lowerbound(k1) = k1
lowerbound(k4) = k6
lowerbound(k7) = k7
[0;36m
Upper Bound[0m
Upper bounds:
upperbound(k1) = k2
upperbound(k2) = k6
upperbound(k4) = k6
end()

Const upper bounds:
upperbound(k1) = k2
upperbound(k2) = k6
upperbound(k4) = k6
end()
[0;36m
Equal range[0m
printing map
  size = 4
  k1 => v1
  k2 => v2
  k6 => v6
  k7 => v7
end of print

Equal range
equal_range(k2) = <k2, k6>
equal_range(k1) = <k1, k2>
equal_range(k5) = <k6, k6>
equal_range(k8) = <end(), end()>

Const equal range
equal_range(k2) = <k2, k6>
equal_range(k1) = <k1, k2>
equal_range(k5) = <k6, k6>
equal_range(k8) = <end(), end()>
[0;36m
Get_allocator[0m
printing map
  size = 1
  k1 => v1
end of print

Pair address through allocator = 0x7ffc897d9850
[0;32mOPERATORS OK[0m
[0;33mSpeed test[0m
[0;36m
Insertion[0m
Map size = 10^n. Enter n:
Create a map with 10 random int
Total seconds = 5.8e-05
[0;36m
Access all elements[0m

Total seconds = 0.000274
[0;36m
Random access[0m
Access random elements 10^7 times
map[929276351]
map[1069123039]
map[1192706203]
map[1612404076]
Total seconds = 0.725615
